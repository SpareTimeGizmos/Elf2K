	.TITLE	 "MUSIC -- Elf 2000 MIDI Tones Interpreter"
;	 Bob Armstrong [22-Feb-12]

;       Copyright (C) 2005 By Spare Time Gizmos, Milpitas CA.

;   This program is free software; you can redistribute it and/or modify
; it under the terms of the GNU General Public License as published by
; the Free Software Foundation; either version 2 of the License, or
; (at your option) any later version.
;
;   This program is distributed in the hope that it will be useful, but
; WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
; or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
; for more details.
;
;   You should have received a copy of the GNU General Public License along
; with this program; if not, write to the Free Software Foundation, Inc.,
; 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
;

; DESCRIPTION
;   This program interprets a byte stream generated by Len Shustek's miditones
; program, 
;
;	http://code.google.com/p/miditones/
;
; Len's program takes a MIDI file and renders it for three basic tone generators
; and then outputs a simple stream of byte codes for the music.  Len documents
; the byte codes fairly well on his web page, so I won't repeat that part here.
;
;   This program then takes that stream of byte codes and plays it using the
; AY-3-8910 sound chip on the Elf 2000.  In this stand alone player version, the
; byte codes must be separately downloaded to RAM starting at address $2000.
;
; LIMITATIONS
;   Right now, Len's program only extracts tone (i.e. note) information from
; the MIDI - everything else is lost.  The 8910 is capable of independently
; controlling the volume for each of the three tone generators and it'd sound
; a lot better if some rudimentary dynamics/volume control was added. 
;
;   

;0000000001111111111222222222233333333334444444444555555555566666666667777777777
;1234567890123456789012345678901234567890123456789012345678901234567890123456789

	.MSFIRST \ .PAGE \ .CODES

	.NOLIST
	.INCLUDE "/elf/sw/eprom/config.inc"
	.INCLUDE "/elf/sw/eprom/elf2k.inc"
	.INCLUDE "/elf/sw/eprom/boots.inc"
	.LIST

; Magic numbers ...
TUNE_TABLE	.EQU	$2000	; where (in RAM) the tune byte codes start
DELAY_1MS	.EQU	90	; constant for 3MHz (see the DELAY routine)
NEWKEY		.EQU	12	; transpose the key (e.g. +12 -> up one octave)
VOLUME		.EQU	7	; default volume (0..15)
PSG_ADDR	.EQU	5	; AY-3-8910 register address (write only)
PSG_DATA	.EQU	1	; AY-3-8910 data port (read/write)

	.EJECT
;++
; REVISION HISTORY
; 
; 001	-- New file (gotta start somewhere!)...
;
; 002	-- Install a better note table (the old one was out of tune!)
;
; 003	-- Add a player volume setting and a key transposition settion
;
; 004	-- Don't hang if the delay value is zero!
;--

	.EJECT
;	.SBTTL	AY-3-8910 Programmable Sound Generator Definitions

;   Note that the AY-3-8910, 8912 and 8913 are all identical as far as the
; software is concerned.  They differ only in package, pin out and hardware
; interface.

;   Another usefule factoid is that the 8910 actually decodes all eight bits of
; the register select address.  Yes, there are only 16 registers so only the
; lower four bits select the register, but the upper four bits MUST be zero or
; the chip will ignore us...  Most of the time, that is - it turns out that GI
; would actually manufacture custom version of the 8910 that expected other,
; non-zero, nibbles on the upper four register select bits.  The idea was to
; allow multiple PSG chips on the same bus to be separately addressed by these
; extra bits in the register address.  Normally any 8910 chip a hobbyist bought
; would want to see zeros on these bits, but these days IC pulls and surplus
; parts have found their way onto the market and you will sometimes find chips
; that want non-zero select codes.  There's no real way to find out, except by
; trial and error...
PSG_SEL	.EQU	$00		; PSG select code*16 (e.g. $10, $20, etc)

;   Define mnemonics for the PSG registers just to make it easier to use the
; GI documentation.  BTW, note that GI numbered the registers in OCTAL!
PSG_R0	.EQU	PSG_SEL+$0	; tone generator low byte, channel A
PSG_R1	.EQU	PSG_SEL+$1	;  "    "    "   high  " ,    "    "
PSG_R2	.EQU	PSG_SEL+$2	;  "    "    "   low byte, channel B
PSG_R3	.EQU	PSG_SEL+$3	;  "    "    "   high  " ,    "    "
PSG_R4	.EQU	PSG_SEL+$4	;  "    "    "   low byte, channel C
PSG_R5	.EQU	PSG_SEL+$5	;  "    "    "   high  " ,    "    "
PSG_R6	.EQU	PSG_SEL+$6	; noise generator control
PSG_R7	.EQU	PSG_SEL+$7	; mixer and I/O control
PSG_R10	.EQU	PSG_SEL+$8	; amplitude control, channel A
PSG_R11	.EQU	PSG_SEL+$9	;  "     "     "        "    B
PSG_R12	.EQU	PSG_SEL+$A	;  "     "     "        "    C
PSG_R13	.EQU	PSG_SEL+$B	; envelope period, low byte
PSG_R14	.EQU	PSG_SEL+$C	;  "    "     "    high  "
PSG_R15	.EQU	PSG_SEL+$D	; envelope shape and cycle control
PSG_R16	.EQU	PSG_SEL+$E	; I/O port A data
PSG_R17	.EQU	PSG_SEL+$F	;  "   "   B   "

; This macro outputs a constant, inline, value to a PSG register ...
#define OUTPSG(r,d)	SEX PC\ OUT PSG_ADDR\ .DB r\ OUT PSG_DATA\ .DB d\ SEX SP

	.EJECT
;	.SBTTL	Initialization and Startup

;   This simple program loads at $0200 and is intended to be started via the Elf
; 2000 monitor's CALL command.  This command does a standard SCRT type call to
; the specified address - that makes this code effectively become a subroutine
; of the monitor.  The context is the same as the monitor's (e.g. the PC is R3,
; X points to the monitor's stack RAM, etc) and we can exit simply by doing a
; standard RETurn.

	.ORG	$0200

; Initialize the PSG ...
	OUTPSG(PSG_R6,  $00)	; disable the noise generator
	OUTPSG(PSG_R7,  $F8)	; turn on tones A, B & C, set IO ports to output
	OUTPSG(PSG_R10, $00)	; mute channel A
	OUTPSG(PSG_R11, $00)	; ... channel B
	OUTPSG(PSG_R12, $00)	; ... and C
	OUTPSG(PSG_R15, $00)	; disable envelope generator (we don't use it)
	OUTPSG(PSG_R16, $00)	; and clear IO port A
	OUTPSG(PSG_R17, $00)	; ... and port B

; Now we're ready to play ....
	RLDI(P4,TUNE_TABLE)	; P4 always points at the tune table
	CALL(PLAYER)		; and away we go!!

; Reset the PSG and we're done...
	OUTPSG(PSG_R16, $00)	; clear IO port A
	OUTPSG(PSG_R17, $00)	; ... and port B
	OUTPSG(PSG_R10, $00)	; mute channel A
	OUTPSG(PSG_R11, $00)	; ... channel B
	OUTPSG(PSG_R12, $00)	; ... and C
	OUTPSG(PSG_R7,  $FF)	; turn off all mixer inputs
	RETURN			; and back to the monitor

	.EJECT
;	.SBTTL	Player Loop

;   Fetch the next byte from the tune.  If the MSB is a zero then it's a delay,
; and if the MSB is 1 it's a tone generator function ...
PLAYER:	LDN	P4		; look ahead at the next byte
	ANI	$80		; check only the MSB
	BNZ	PLAY1		; branch if it's a tone generator function

; It's a delay - this byte and the next byte are the interval, in milliseconds.
	LDA	P4		; get the first delay byte
	PHI	P1		; they're in big endian ordering
	LDA	P4		; and the second delay byte
	PLO	P1		; ...
	CALL(DELAY)		; generate that interval, in milliseconds
	BR	PLAYER		; and keep playing

;   It's not a delay.  A byte of $9t (where 't' is the tone generator number)
; starts a tone playing, and $89 stops it.  Officially the only other defined
; value is $F0, which means end of tune, but we interpret anything else as the
; end and stop playing.
PLAY1:	LDN	P4		; get the byte code again
	ANI	$F0		; look at just the top nibble
	SMI	$90		; check for $80 or $90
	BZ	PLAY3		; branch if $80 - start a tone
	BL	PLAY2		; branch if $90 - stop a tone
	RETURN			; otherwise we're done playing - quit!

;   Stop a tone generator.  This is a single byte code, and the lower nibble is
; the tone generator index - 0, 1 or 2.  In theory there could be more tone
; generators (up to 16, I guess) but we don't deal well with that case...
PLAY2:	LDA	P4		; get the command one more time
	ANI	$0F		; get only the generator number
	BNZ	PLAY20		; if it's not zero, check channel B or C
	CALL(MUTEA)		; mute channel A
	BR	PLAYER		; ... and we're done
PLAY20:	SMI	1		; is it B or C ??
	BNZ	PLAY21		; branch if channel C
	CALL(MUTEB)		; nope - mute channel B
	BR	PLAYER		; ...
PLAY21:	CALL(MUTEC)		; here if channel C
	BR	PLAYER		; ...


;   Start a tone generator.  This is a two byte code - the lower nibble of the
; first byte is the tone generator number, just like for MUTE.  The second
; byte is the MIDI note number, from 0 to 127.  The MIDI note number we have to
; actually look up in the note table in order to translate it to a counter
; value for the 8910 tone generator...
PLAY3:	LDA	P4		; dispatch by the tone generator number
	ANI	$0F		; ...
	BNZ	PLAY30		; ... check channel B or C
	LDA	P4		; channel A - get the note number
	CALL(PLAYA)		; ... and play
	BR	PLAYER		; ... and we're done
PLAY30:	SMI	1		; is it B or C ??
	BNZ	PLAY31		; branch if channel C
	LDA	P4		; get the note
	CALL(PLAYB)		; ... and play channel B
	BR	PLAYER		; ...
PLAY31:	LDA	P4		; get the note
	CALL(PLAYC)		; ... and play channel C
	BR	PLAYER		; ...

	.EJECT
;	.SBTTL	Control the Tone Generators

; Play the MIDI note in D on tone generator A ...
PLAYA:	CALL(LDNOTE)		; get the tone generator setting
	GLO	P1		; get the low tone byte
	CALL(WRPSG)		; and write to R0
	 .DB	 PSG_R0		;  ....
	GHI	P1		; then write the high byte
	CALL(WRPSG)		;  ....
	 .DB	 PSG_R1		;  ... to R1
	OUTPSG(PSG_R10, VOLUME)	; and finally unmute channel A
	RETURN			; all done

; Play the MIDI note in D on tone generator B ...
PLAYB:	CALL(LDNOTE)		; get the tone generator setting
	GLO	P1		; get the low tone byte
	CALL(WRPSG)		; and write to R2
	 .DB	 PSG_R2		;  ....
	GHI	P1		; then write the high byte
	CALL(WRPSG)		;  ....
	 .DB	 PSG_R3		;  ... to R3
	OUTPSG(PSG_R11, VOLUME)	; and finally unmute channel B
	RETURN			; all done

; Play the MIDI note in D on tone generator C ...
PLAYC:	CALL(LDNOTE)		; get the tone generator setting
	GLO	P1		; get the low tone byte
	CALL(WRPSG)		; and write to R4
	 .DB	 PSG_R4		;  ....
	GHI	P1		; then write the high byte
	CALL(WRPSG)		;  ....
	 .DB	 PSG_R5		;  ... to R5
	OUTPSG(PSG_R12, VOLUME)	; and finally unmute channel C
	RETURN			; all done

; Mute channel A ...
MUTEA:	OUTPSG(PSG_R10, $00)	; just set the volume to zero
	RETURN			; ...

; Mute channel B ...
MUTEB:	OUTPSG(PSG_R11, $00)	; ...
	RETURN			; ...

; Mute channel C ...
MUTEC:	OUTPSG(PSG_R12, $00)	; ...
	RETURN			; ...

	.EJECT
;	.SBTTL	Miscellaneous Subroutines


; Write the byte in D to the PSG register indicated inline ...
WRPSG:	SEX	A		; point X at the inline register number
	OUT	PSG_ADDR	; send it to the PSG, increment A
	SEX	SP		; back to the stack
	STR	SP		; save D on the TOS
	OUT	PSG_DATA	; and write the data byte
	DEC	SP		; correct for OUT, which increments X
	RETURN			; and we're done


; Read the PSG register indicated inline, return the result in D ...
RDPSG:	SEX	A		; point X at the register (inline)
	OUT	PSG_ADDR	; select that register, increment A
	SEX	SP		; point X at the TOS again
	INP	PSG_DATA	; read the register into D and the TOS
	RETURN			; that's all


;   This routine delays for a the number of milliseconds specified by P1.  For
; a 3MHz clock each machine cycle takes 2.66uS - that's 375 machine cycles per
; millisecond.   Note that the delay is only approximate and there are several
; errors that creep in, but it's pointless to try and make it exact.  We haven't
; accounted for the overhead in the SCRT call/return or even in the main player
; loop, and that'll swamp any errors here...
DELAY0:	LDI	DELAY_1MS	; [2] about 90 times for 3MHz
	SMI	1		; [2] this loop wastes 4*DELAY_1MS cycles
	BNZ	$-2		; [2] ...
	DEC	P1		; [2] count down
DELAY:	GHI	P1		; [2] and wait for zero
	STR	SP		; [2] stash it on the stack
	GLO	P1		; [2] ...
	OR			; [2] combine both bytes
	BNZ	DELAY0		; [2] and branch if it's not zero yet
	RETURN


; Load the note table entry for the note in D into P1 ...
LDNOTE:	ADI	NEWKEY		; transpose the note if desired
	SHL			; multiply the index by two
	PLO	T1		; and save that in the pointer
	LDI	HIGH(NOTES)	; then set the high part 
	PHI	T1		;  ... of the pointer too
	LDA	T1		; get the high byte
	PHI	P1		; ...
	LDN	T1		; and the low byte
	PLO	P1		; ...
	RETURN			; ...

	.EJECT
;	.SBTTL	MIDI Note Table

;   This table is indexed by the MIDI note number, 0..127, and gives the
; corresponding 8910 tone generator setting.  These values are calculated
; assuming a 2MHz clock for the 8910 - if yours uses a different value you'll
; have to scale them appropriately. 
;
;   Note that each entry is a word value and this table is conveniently aligned
; on a page boundary, so to compute an index you can just take the note number,
; shift left once, and use that for the low byte of the pointer.  The high
; byte comes directly from this table's address...

	.ORG	($+$00FF) & $FF00
NOTES:
	.DW	14090, 13300, 12553, 11849, 11184, 10556,  9963,  9404	;   0 -   7
	.DW	 8876,  8378,  7908,  7464,  7045,  6650,  6277,  5924	;   8 -  15
	.DW	 5592,  5278,  4982,  4702,  4438,  4189,  3954,  3732	;  16 -  23
	.DW	 3523,  3325,  3138,  2962,  2796,  2639,  2491,  2351	;  24 -  31
	.DW	 2219,  2095,  1977,  1866,  1761,  1662,  1569,  1481	;  32 -  39
	.DW	 1398,  1319,  1245,  1176,  1110,  1047,   988,   933	;  40 -  47
	.DW	  881,   831,   785,   741,   699,   660,   623,   588	;  48 -  55
	.DW	  555,   524,   494,   467,   440,   416,   392,   370	;  56 -  63
	.DW	  349,   330,   311,   294,   277,   262,   247,   233	;  64 -  71
	.DW	  220,   208,   196,   185,   175,   165,   156,   147	;  72 -  79
	.DW	  139,   131,   124,   117,   110,   104,    98,    93	;  80 -  87
	.DW	   87,    82,    78,    73,    69,    65,    62,    58	;  88 -  95
	.DW	   55,    52,    49,    46,    44,    41,    39,    37	;  96 - 103
	.DW	   35,    33,    31,    29,    28,    26,    25,    23	; 104 - 111
	.DW	   22,    21,    19,    18,    17,    16,    15,    15	; 112 - 119
	.DW	   14,    13,    12,    12,    11,    10,    10,     9	; 120 - 127

	.END
